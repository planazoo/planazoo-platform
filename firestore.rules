rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // FUNCIONES AUXILIARES
    // ============================================
    
    // Verificar que el usuario está autenticado
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Verificar si el usuario es administrador de la plataforma
    // Los administradores tienen permisos completos para gestión y mantenimiento
    function isAdmin(userId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.isAdmin == true;
    }
    
    // Verificar si el plan existe
    function planExists(planId) {
      return exists(/databases/$(database)/documents/plans/$(planId));
    }
    
    // Verificar si el usuario es el creador del plan
    function isPlanOwner(planId) {
      return isAuthenticated() && 
             planExists(planId) &&
             get(/databases/$(database)/documents/plans/$(planId)).data.userId == request.auth.uid;
    }
    
    // Verificar si el usuario es participante del plan
    // NOTA IMPORTANTE: Como las participaciones usan IDs generados por Firestore (no compuestos),
    // no podemos hacer queries en reglas para verificar participación. Por lo tanto:
    // 1. El owner siempre es participante (verificado directamente)
    // 2. Para otros usuarios, las reglas verifican owner del recurso o datos básicos
    // 3. La verificación completa de participación se hace en el código cliente usando queries
    // 4. Las reglas son más permisivas para lectura pero restrictivas para escritura
    function isPlanParticipant(planId) {
      return isAuthenticated() && isPlanOwner(planId);
    }
    
    // Obtener el rol del usuario en el plan
    // NOTA: Como no podemos hacer queries en reglas, asumimos owner = admin
    // Las funciones en Firestore Rules no pueden usar if/return, solo expresiones
    function getUserRole(planId) {
      return isPlanOwner(planId) ? 'admin' : 'participant';
    }
    
    // Verificar si el usuario es organizador o admin del plan
    function isPlanAdmin(planId) {
      return isPlanOwner(planId) || 
             (isPlanParticipant(planId) && getUserRole(planId) == 'admin');
    }
    
    // Verificar si el usuario puede editar contenido del plan
    function canEditPlanContent(planId) {
      return isPlanAdmin(planId) || 
             (isPlanParticipant(planId) && getUserRole(planId) == 'participant');
    }
    
    // Verificar si el usuario puede leer contenido del plan (incluye observers)
    function canReadPlanContent(planId) {
      return isPlanParticipant(planId);
    }
    
    // Validar estructura básica de plan
    function isValidPlanData() {
      return request.resource.data.keys().hasAll(['name', 'unpId', 'userId', 'baseDate', 'columnCount', 'createdAt', 'updatedAt']) &&
             request.resource.data.name is string &&
             request.resource.data.name.size() >= 3 &&
             request.resource.data.name.size() <= 100 &&
             request.resource.data.unpId is string &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid &&
             // Validar campos opcionales si existen
             (!('state' in request.resource.data) || request.resource.data.state in ['borrador', 'planificando', 'confirmado', 'en_curso', 'finalizado', 'cancelado']) &&
             (!('visibility' in request.resource.data) || request.resource.data.visibility in ['private', 'public']) &&
             (!('timezone' in request.resource.data) || request.resource.data.timezone is string);
    }
    
    // Validar estructura básica de evento
    function isValidEventData(planId) {
      return request.resource.data.keys().hasAll(['planId', 'userId', 'date', 'hour', 'description', 'createdAt', 'updatedAt']) &&
             request.resource.data.planId == planId &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.description is string &&
             request.resource.data.description.size() >= 3 &&
             request.resource.data.description.size() <= 1000;
    }
    
    // Validar estructura básica de alojamiento
    function isValidAccommodationData(planId) {
      return request.resource.data.keys().hasAll(['planId', 'checkIn', 'checkOut', 'hotelName', 'createdAt', 'updatedAt']) &&
             request.resource.data.planId == planId &&
             request.resource.data.hotelName is string &&
             request.resource.data.hotelName.size() >= 2 &&
             request.resource.data.hotelName.size() <= 100;
    }
    
    // Validar estructura básica de aviso
    function isValidAnnouncementData(planId) {
      return request.resource.data.keys().hasAll(['planId', 'userId', 'message', 'createdAt']) &&
             request.resource.data.planId == planId &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.message is string &&
             request.resource.data.message.size() >= 1 &&
             request.resource.data.message.size() <= 1000 &&
             (!('type' in request.resource.data) || request.resource.data.type in ['info', 'urgent', 'important']);
    }
    
    // Validar estructura básica de mensaje de chat
    function isValidMessageData(planId) {
      return request.resource.data.keys().hasAll(['planId', 'userId', 'message', 'createdAt', 'updatedAt']) &&
             request.resource.data.planId == planId &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.message is string &&
             request.resource.data.message.size() >= 1 &&
             request.resource.data.message.size() <= 5000 &&
             request.resource.data.createdAt is timestamp &&
             request.resource.data.updatedAt is timestamp &&
             request.resource.data.readBy is list &&
             (!('replyTo' in request.resource.data) || request.resource.data.replyTo is string);
    }
    
    // Validar estructura básica de participación
    function isValidParticipationData(planId) {
      return request.resource.data.keys().hasAll(['planId', 'userId', 'role', 'joinedAt']) &&
             request.resource.data.planId == planId &&
             request.resource.data.userId is string &&
             request.resource.data.role is string &&
             request.resource.data.role in ['organizer', 'participant', 'observer'] &&
             (!('status' in request.resource.data) || request.resource.data.status in ['pending', 'accepted', 'rejected', 'expired']);
    }
    
    // Validar estructura de datos de participante de evento
    function isValidEventParticipantData() {
      return request.resource.data.keys().hasAll(['eventId', 'userId', 'registeredAt']) &&
             request.resource.data.eventId is string &&
             request.resource.data.userId is string &&
             request.resource.data.registeredAt is timestamp &&
             (!('status' in request.resource.data) || 
              request.resource.data.status in ['registered', 'cancelled']) &&
             (!('confirmationStatus' in request.resource.data) || 
              request.resource.data.confirmationStatus in ['pending', 'confirmed', 'declined']);
    }
    
    // Validar estructura de datos de grupo de participantes
    function isValidParticipantGroupData() {
      return request.resource.data.keys().hasAll(['userId', 'name', 'createdAt', 'updatedAt']) &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid &&
             request.resource.data.name is string &&
             request.resource.data.name.size() >= 1 &&
             request.resource.data.name.size() <= 100 &&
             request.resource.data.createdAt is timestamp &&
             request.resource.data.updatedAt is timestamp &&
             request.resource.data.memberUserIds is list &&
             request.resource.data.memberEmails is list &&
             (!('description' in request.resource.data) || 
              (request.resource.data.description is string && 
               request.resource.data.description.size() <= 500)) &&
             (!('icon' in request.resource.data) || 
              (request.resource.data.icon is string && 
               request.resource.data.icon.size() <= 10)) &&
             (!('color' in request.resource.data) || 
              request.resource.data.color is string);
    }
    
    // Validar estructura de datos de pago personal
    function isValidPersonalPaymentData() {
      return request.resource.data.keys().hasAll(['planId', 'participantId', 'amount', 'paymentDate', 'status', 'createdAt', 'updatedAt']) &&
             request.resource.data.planId is string &&
             request.resource.data.participantId is string &&
             request.resource.data.amount is number &&
             request.resource.data.amount > 0 &&
             request.resource.data.amount <= 1000000 &&
             request.resource.data.paymentDate is timestamp &&
             request.resource.data.status in ['pending', 'paid', 'refunded'] &&
             request.resource.data.createdAt is timestamp &&
             request.resource.data.updatedAt is timestamp &&
             (!('eventId' in request.resource.data) || 
              request.resource.data.eventId is string) &&
             (!('paymentMethod' in request.resource.data) || 
              request.resource.data.paymentMethod is string) &&
             (!('concept' in request.resource.data) || 
              (request.resource.data.concept is string && 
               request.resource.data.concept.size() <= 100)) &&
             (!('description' in request.resource.data) || 
              (request.resource.data.description is string && 
               request.resource.data.description.size() <= 500)) &&
             (!('registeredBy' in request.resource.data) || 
              request.resource.data.registeredBy is string);
    }
    
    // Validar estructura de datos de tipo de cambio
    function isValidExchangeRateData() {
      return request.resource.data.keys().hasAll(['baseCurrency', 'rates', 'updatedAt']) &&
             request.resource.data.baseCurrency is string &&
             request.resource.data.rates is map &&
             request.resource.data.updatedAt is timestamp;
    }
    
    // Validar estructura de datos de permiso de plan
    function isValidPlanPermissionData() {
      return request.resource.data.keys().hasAll(['planId', 'userId', 'role', 'assignedAt']) &&
             request.resource.data.planId is string &&
             request.resource.data.userId is string &&
             request.resource.data.role is string &&
             request.resource.data.assignedAt is timestamp &&
             request.resource.data.permissions is list &&
             (!('assignedBy' in request.resource.data) || 
              request.resource.data.assignedBy is string) &&
             (!('expiresAt' in request.resource.data) || 
              request.resource.data.expiresAt is timestamp) &&
             (!('metadata' in request.resource.data) || 
              request.resource.data.metadata is map);
    }
    
    // Validar estructura de datos de invitación de plan
    function isValidPlanInvitationData() {
      return request.resource.data.keys().hasAll(['planId', 'email', 'token', 'createdAt', 'expiresAt']) &&
             request.resource.data.planId is string &&
             request.resource.data.email is string &&
             request.resource.data.token is string &&
             request.resource.data.createdAt is timestamp &&
             request.resource.data.expiresAt is timestamp &&
             (!('status' in request.resource.data) || 
              request.resource.data.status in ['pending', 'accepted', 'rejected', 'expired']) &&
             (!('role' in request.resource.data) || 
              request.resource.data.role in ['participant', 'observer']);
    }
    
    // ============================================
    // REGLAS PARA USUARIOS
    // ============================================
    
    match /users/{userId} {
      // Cualquier usuario autenticado puede leer perfiles públicos
      // Los administradores pueden leer todos los perfiles
      allow read: if isAuthenticated();
      
      // Permitir consultas de usernameLower sin autenticación (solo para verificar disponibilidad durante registro)
      // Limitado a consultas con límite de 1 para evitar listar todos los usuarios
      // Esto es seguro porque solo permite verificar si un username específico existe
      // Los administradores pueden listar sin límite
      allow list: if request.query.limit <= 1 || isAdmin(request.auth.uid);
      
      // Solo el propio usuario puede crear su perfil
      // Los administradores pueden crear perfiles (útil para gestión)
      allow create: if (isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.keys().hasAll(['email', 'createdAt']) &&
                       request.resource.data.email is string &&
                       request.resource.data.email.size() > 0 &&
                       request.resource.data.createdAt is timestamp) ||
                      isAdmin(request.auth.uid);
      
      // Solo el propio usuario puede actualizar su perfil
      // Los administradores pueden actualizar cualquier perfil (útil para correcciones)
      allow update: if (isAuthenticated() && 
                       request.auth.uid == userId &&
                       (!('email' in request.resource.data.diff(resource.data).affectedKeys()) ||
                        request.resource.data.email == resource.data.email)) || // No permitir cambiar email
                      isAdmin(request.auth.uid);
      
      // Solo el propio usuario puede eliminar su perfil (con validación adicional en el cliente)
      // Los administradores pueden eliminar perfiles (útil para limpieza)
      allow delete: if (isAuthenticated() && request.auth.uid == userId) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA PLANES
    // ============================================
    
    match /plans/{planId} {
      // Crear: Solo usuarios autenticados pueden crear planes
      // Los administradores pueden crear planes
      allow create: if (isAuthenticated() && isValidPlanData()) || isAdmin(request.auth.uid);
      
      // Leer: 
      //  - Usuarios autenticados pueden leer (validación completa en cliente)
      //  - Los administradores pueden leer todos los planes
      //  - IMPORTANTE: Permitir lectura pública para que usuarios no autenticados puedan ver planes desde invitaciones
      //    Esto es necesario para que la página de invitación funcione sin autenticación
      //    NOTA: La verificación de participación real se hace en el código cliente
      allow read: if isAuthenticated() || true; // Permitir lectura pública (necesario para invitaciones)
      
      // Actualizar: Solo owner del plan puede actualizar
      // Los administradores pueden actualizar cualquier plan
      allow update: if (isPlanOwner(planId) &&
                       request.resource.data.userId == resource.data.userId && // No permitir cambiar owner
                       request.resource.data.createdAt == resource.data.createdAt) || // No permitir cambiar fecha creación
                      isAdmin(request.auth.uid);
      
      // Eliminar: Solo el creador original puede eliminar el plan
      // Los administradores pueden eliminar cualquier plan
      allow delete: if isPlanOwner(planId) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA EVENTOS (colección raíz)
    // NOTA: Los eventos están en la colección raíz 'events', no como subcolección
    // ============================================
    
    match /events/{eventId} {
      // Crear: Solo usuarios autenticados pueden crear eventos
      // Los administradores pueden crear eventos
      // La verificación de participación se hace en el código cliente
      allow create: if (isAuthenticated() && isValidEventData(request.resource.data.planId)) || isAdmin(request.auth.uid);
      
      // Leer: Usuarios autenticados pueden leer eventos
      // Los administradores pueden leer todos los eventos
      // La validación de participación se hace en el código cliente
      allow read: if isAuthenticated();
      
      // Actualizar: 
      // - Owner del plan: puede editar cualquier evento
      // - Creador del evento: puede editar su evento
      // - Administradores: pueden editar cualquier evento
      allow update: if (isAuthenticated() && (
        isPlanOwner(resource.data.planId) || // Owner del plan puede editar todo
        resource.data.userId == request.auth.uid // Creador puede editar
      ) && isValidEventData(resource.data.planId)) || isAdmin(request.auth.uid);
      
      // Eliminar: Solo owner del plan o creador del evento puede eliminar
      // Los administradores pueden eliminar cualquier evento
      allow delete: if (isAuthenticated() && 
                       (isPlanOwner(resource.data.planId) || resource.data.userId == request.auth.uid)) ||
                      isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA ALOJAMIENTOS (colección raíz 'events' con typeFamily='alojamiento')
    // NOTA: Los alojamientos están en la colección 'events' con typeFamily='alojamiento'
    // ============================================
    
    // Los alojamientos usan la misma colección 'events', así que usan las mismas reglas
    // Se distinguen por el campo 'typeFamily' = 'alojamiento'
    
    // ============================================
    // REGLAS PARA PAGOS (subcolección de planes) - T101, T102
    // ============================================
    
    match /plans/{planId}/payments/{paymentId} {
      // Crear: Solo usuarios autenticados pueden crear sus propios pagos
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      
      // Leer: Usuarios autenticados pueden leer pagos (validación completa en cliente)
      allow read: if isAuthenticated();
      
      // Actualizar: Solo el propietario del pago puede actualizar
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;
      
      // Eliminar: Solo el propietario del pago puede eliminar
      allow delete: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid;
    }
    
    // ============================================
    // REGLAS PARA AVISOS/NOTIFICACIONES (subcolección de planes) - T105
    // ============================================
    
    match /plans/{planId}/announcements/{announcementId} {
      // Crear: Solo usuarios autenticados pueden crear avisos con validación
      allow create: if isAuthenticated() &&
                       isValidAnnouncementData(planId);
      
      // Leer: Usuarios autenticados pueden leer avisos (validación completa en cliente)
      allow read: if isAuthenticated();
      
      // Actualizar: Solo el creador del aviso o owner del plan puede actualizar
      allow update: if isAuthenticated() && 
                       (isPlanOwner(planId) || resource.data.userId == request.auth.uid);
      
      // Eliminar: Solo el creador del aviso o owner del plan puede eliminar
      allow delete: if isAuthenticated() && 
                       (isPlanOwner(planId) || resource.data.userId == request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA MENSAJES DE CHAT (subcolección de planes) - T190
    // ============================================
    
    match /plans/{planId}/messages/{messageId} {
      // Crear: Solo usuarios autenticados pueden crear mensajes con validación
      // La verificación de participación en el plan se hace en el cliente
      allow create: if isAuthenticated() &&
                       isValidMessageData(planId);
      
      // Leer y listar: Usuarios autenticados pueden leer/listar mensajes
      // La verificación de participación en el plan se hace en el cliente
      // NOTA: read incluye tanto get como list, así que no necesitamos list por separado
      allow read: if isAuthenticated();
      
      // Actualizar: 
      // - El autor del mensaje puede editar su mensaje (solo message, editedAt, updatedAt)
      // - Cualquier usuario puede marcar mensajes como leídos (solo readBy, updatedAt)
      // - El autor puede eliminar su mensaje (soft delete: solo deletedAt, updatedAt)
      allow update: if isAuthenticated() && (
        // Editar mensaje propio
        (resource.data.userId == request.auth.uid &&
         request.resource.data.userId == resource.data.userId &&
         request.resource.data.planId == resource.data.planId &&
         request.resource.data.createdAt == resource.data.createdAt &&
         (!('deletedAt' in request.resource.data) || request.resource.data.deletedAt == resource.data.deletedAt) &&
         (!('readBy' in request.resource.data) || request.resource.data.readBy == resource.data.readBy) &&
         (!('replyTo' in request.resource.data) || request.resource.data.replyTo == resource.data.replyTo)) ||
        // Marcar como leído (cualquier usuario puede añadirse a readBy)
        (request.resource.data.userId == resource.data.userId &&
         request.resource.data.planId == resource.data.planId &&
         request.resource.data.message == resource.data.message &&
         request.resource.data.createdAt == resource.data.createdAt &&
         (!('editedAt' in request.resource.data) || request.resource.data.editedAt == resource.data.editedAt) &&
         (!('deletedAt' in request.resource.data) || request.resource.data.deletedAt == resource.data.deletedAt) &&
         (!('replyTo' in request.resource.data) || request.resource.data.replyTo == resource.data.replyTo) &&
         'readBy' in request.resource.data.diff(resource.data).affectedKeys()) ||
        // Soft delete (solo el autor)
        (resource.data.userId == request.auth.uid &&
         request.resource.data.userId == resource.data.userId &&
         request.resource.data.planId == resource.data.planId &&
         request.resource.data.message == resource.data.message &&
         request.resource.data.createdAt == resource.data.createdAt &&
         (!('editedAt' in request.resource.data) || request.resource.data.editedAt == resource.data.editedAt) &&
         (!('readBy' in request.resource.data) || request.resource.data.readBy == resource.data.readBy) &&
         (!('replyTo' in request.resource.data) || request.resource.data.replyTo == resource.data.replyTo) &&
         'deletedAt' in request.resource.data.diff(resource.data).affectedKeys())
      );
      
      // Eliminar: No se permite hard delete, solo soft delete (marcar deletedAt)
      // Los administradores pueden eliminar mensajes (útil para moderación)
      allow delete: if isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA PARTICIPACIONES
    // ============================================
    
    match /plan_participations/{participationId} {
      // Crear: Cualquier usuario autenticado puede crear su propia participación
      // o el owner del plan puede crear participaciones
      // Los administradores pueden crear participaciones
      allow create: if (isAuthenticated() && (
        request.resource.data.userId == request.auth.uid || // Usuario acepta su propia invitación
        isPlanOwner(request.resource.data.planId) // Owner añade participante
      ) && isValidParticipationData(request.resource.data.planId)) || isAdmin(request.auth.uid);
      
      // Leer: Usuarios autenticados pueden leer participaciones
      // - Pueden leer su propia participación
      // - Pueden leer participaciones si son owner del plan
      // Los administradores pueden leer todas las participaciones
      allow read: if (isAuthenticated() && 
                     (request.auth.uid == resource.data.userId ||
                      isPlanOwner(resource.data.planId))) || isAdmin(request.auth.uid);
      
      // Listar: Necesario para consultas con where() y orderBy()
      // IMPORTANTE: Las consultas con múltiples where() requieren permisos de list
      // La validación de participación se hace en el cliente
      // Los administradores pueden listar todas las participaciones
      allow list: if isAuthenticated();
      
      // Actualizar: Solo owner del plan puede cambiar roles
      // O el propio usuario puede actualizar su status (aceptar/rechazar invitación) o timezone
      // Los administradores pueden actualizar cualquier participación
      allow update: if (isAuthenticated() && (
        isPlanOwner(resource.data.planId) || // Owner puede cambiar roles y status
        (request.auth.uid == resource.data.userId && // Usuario puede actualizar su info
         (
           // Usuario puede aceptar/rechazar invitación (cambiar status de pending a accepted/rejected)
           ('status' in request.resource.data.diff(resource.data).affectedKeys() && 
            !('role' in request.resource.data.diff(resource.data).affectedKeys())) ||
           // O puede actualizar su timezone
           ('personalTimezone' in request.resource.data.diff(resource.data).affectedKeys() &&
            !('role' in request.resource.data.diff(resource.data).affectedKeys()) &&
            !('status' in request.resource.data.diff(resource.data).affectedKeys()))
         )
        )
      )) || isAdmin(request.auth.uid);
      
      // Eliminar: 
      // - Owner del plan puede eliminar participaciones (si el plan existe)
      // - Usuario puede eliminar su propia participación si el plan no existe (huérfana)
      // - Los administradores pueden eliminar cualquier participación (útil para limpiar huérfanas)
      allow delete: if (isAuthenticated() && (
                       isPlanOwner(resource.data.planId) || // Owner del plan
                       (!planExists(resource.data.planId) && // Plan no existe (huérfana)
                        resource.data.userId == request.auth.uid) // Y es la propia participación
                     )) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA PARTICIPANTES POR EVENTO (T117)
    // ============================================
    
    match /event_participants/{participantId} {
      // Crear: Solo usuarios que participan en el plan pueden apuntarse a eventos
      // Verificar que el usuario participa en el plan del evento
      // Los administradores pueden crear participantes
      allow create: if (isAuthenticated() && 
                       isValidEventParticipantData() &&
                       request.resource.data.userId == request.auth.uid) || isAdmin(request.auth.uid);
      
      // Leer: Cualquier usuario autenticado puede leer participantes del evento
      // Los administradores pueden leer todos los participantes
      // IMPORTANTE: Las consultas con múltiples where() y orderBy() requieren índices compuestos
      // La validación de participación en el plan se hace en el cliente
      allow read: if isAuthenticated();
      
      // Listar: Necesario para consultas con where() y orderBy()
      // Firestore diferencia entre leer un documento individual (read) y listar documentos (list)
      // Los administradores pueden listar todos los participantes
      allow list: if isAuthenticated();
      
      // Actualizar: Solo el mismo usuario puede actualizar su confirmationStatus o status (T120 Fase 2)
      // Los administradores pueden actualizar cualquier participante
      allow update: if (isAuthenticated() && 
                       isValidEventParticipantData() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid &&
                       // Solo se pueden actualizar confirmationStatus y status, no otros campos críticos
                       request.resource.data.eventId == resource.data.eventId &&
                       request.resource.data.registeredAt == resource.data.registeredAt) || isAdmin(request.auth.uid);
      
      // Eliminar: Solo el mismo usuario o el owner del plan
      // Los administradores pueden eliminar cualquier participante
      allow delete: if (isAuthenticated() && (
                       resource.data.userId == request.auth.uid ||
                       // El owner del plan puede eliminar (se verifica en cliente que sea owner)
                       false // Se valida en cliente que el usuario es owner del plan
                     )) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA GRUPOS DE PARTICIPANTES - T123
    // ============================================
    
    match /participant_groups/{groupId} {
      // Crear: Solo usuarios autenticados pueden crear grupos
      allow create: if isAuthenticated() && 
                       isValidParticipantGroupData();
      
      // Leer: Solo el propietario puede leer sus grupos
      allow read: if isAuthenticated() && 
                     resource.data.userId == request.auth.uid;
      
      // Actualizar: Solo el propietario puede actualizar
      allow update: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid &&
                       isValidParticipantGroupData() &&
                       request.resource.data.userId == resource.data.userId && // No cambiar propietario
                       request.resource.data.createdAt == resource.data.createdAt; // No cambiar fecha creación
      
      // Eliminar: Solo el propietario puede eliminar
      allow delete: if isAuthenticated() && 
                       resource.data.userId == request.auth.uid;
    }
    
    // ============================================
    // REGLAS PARA PREFERENCIAS DE USUARIO
    // ============================================
    
    match /userPreferences/{userId} {
      // Solo el propio usuario puede leer/escribir sus preferencias
      allow read, write: if isAuthenticated() && 
                           request.auth.uid == userId;
    }
    
    // ============================================
    // REGLAS PARA TOKENS FCM (Fase 1 - FCM Básico)
    // ============================================
    
    match /users/{userId}/fcmTokens/{tokenId} {
      // Crear: Solo el propio usuario puede crear su token
      allow create: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.keys().hasAll(['token', 'deviceInfo', 'createdAt', 'updatedAt']) &&
                       request.resource.data.token is string &&
                       request.resource.data.token == tokenId &&
                       request.resource.data.deviceInfo is map &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;
      
      // Leer: Solo el propio usuario puede leer sus tokens
      allow read: if isAuthenticated() && 
                     request.auth.uid == userId;
      
      // Actualizar: Solo el propio usuario puede actualizar su token (para actualizar updatedAt)
      allow update: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.token == resource.data.token && // No cambiar el token
                       request.resource.data.deviceInfo == resource.data.deviceInfo && // No cambiar deviceInfo
                       request.resource.data.createdAt == resource.data.createdAt; // No cambiar createdAt
      
      // Eliminar: Solo el propio usuario puede eliminar su token
      allow delete: if isAuthenticated() && 
                       request.auth.uid == userId;
    }
    
    // ============================================
    // REGLAS PARA NOTIFICACIONES (Sistema In-App)
    // ============================================
    
    match /users/{userId}/notifications/{notificationId} {
      // Crear: Solo el propio usuario puede crear sus notificaciones
      // (En la práctica, las notificaciones se crean desde Cloud Functions o servicios)
      allow create: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.keys().hasAll(['userId', 'type', 'title', 'body', 'isRead', 'createdAt']) &&
                       request.resource.data.userId == userId &&
                       request.resource.data.type is string &&
                       request.resource.data.title is string &&
                       request.resource.data.body is string &&
                       request.resource.data.isRead is bool &&
                       request.resource.data.createdAt is timestamp;
      
      // Leer: Solo el propio usuario puede leer sus notificaciones
      allow read: if isAuthenticated() && 
                     request.auth.uid == userId;
      
      // Listar: Necesario para consultas con where() y orderBy()
      allow list: if isAuthenticated() && 
                     request.auth.uid == userId;
      
      // Actualizar: Solo el propio usuario puede actualizar sus notificaciones
      // (Principalmente para marcar como leída)
      allow update: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.userId == resource.data.userId && // No cambiar userId
                       request.resource.data.type == resource.data.type && // No cambiar type
                       request.resource.data.title == resource.data.title && // No cambiar title
                       request.resource.data.body == resource.data.body && // No cambiar body
                       request.resource.data.createdAt == resource.data.createdAt && // No cambiar createdAt
                       (!('planId' in request.resource.data) || request.resource.data.planId == resource.data.planId) &&
                       (!('eventId' in request.resource.data) || request.resource.data.eventId == resource.data.eventId);
      
      // Eliminar: Solo el propio usuario puede eliminar sus notificaciones
      allow delete: if isAuthenticated() && 
                       request.auth.uid == userId;
    }
    
    // ============================================
    // REGLAS PARA PAGOS PERSONALES (T102)
    // ============================================
    
    match /personal_payments/{paymentId} {
      // Crear: Usuarios autenticados pueden registrar pagos
      // Deben ser participantes del plan (verificado en cliente)
      // Los administradores pueden crear pagos
      allow create: if (isAuthenticated() && isValidPersonalPaymentData()) || isAdmin(request.auth.uid);
      
      // Leer: Solo participantes del plan pueden leer pagos
      // Los administradores pueden leer todos los pagos
      // (verificado en cliente que el usuario es participante)
      allow read: if isAuthenticated();
      
      // Actualizar: Cualquier participante autenticado puede actualizar
      // Los administradores pueden actualizar cualquier pago
      // (para corregir errores, cambiar estado, etc.)
      allow update: if (isAuthenticated() && 
                       isValidPersonalPaymentData() &&
                       request.resource.data.planId == resource.data.planId &&
                       request.resource.data.participantId == resource.data.participantId) ||
                      isAdmin(request.auth.uid);
      
      // Eliminar: Cualquier participante autenticado puede eliminar
      // Los administradores pueden eliminar cualquier pago
      // (para corregir errores de registro)
      allow delete: if isAuthenticated() || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA TIPOS DE CAMBIO (T153)
    // ============================================
    
    match /exchange_rates/{documentId} {
      // Leer: Cualquiera autenticado puede leer tipos de cambio
      allow read: if isAuthenticated();
      
      // Crear/Actualizar: Solo administradores (por ahora, cualquier autenticado para desarrollo)
      // TODO: Restringir a roles de administrador cuando esté implementado
      allow write: if isAuthenticated() && isValidExchangeRateData();
    }
    
    // ============================================
    // REGLAS PARA PERMISOS DE PLAN (plan_permissions)
    // ============================================
    
    match /plan_permissions/{permissionId} {
      // Crear: Solo el owner del plan puede asignar permisos
      // Los administradores pueden crear permisos
      allow create: if (isAuthenticated() && 
                       isValidPlanPermissionData() &&
                       isPlanOwner(request.resource.data.planId) &&
                       // El ID del documento debe ser '{planId}_{userId}'
                       permissionId == request.resource.data.planId + '_' + request.resource.data.userId) ||
                      isAdmin(request.auth.uid);
      
      // Leer: 
      // - El propio usuario puede leer sus permisos
      // - El owner del plan puede leer todos los permisos del plan
      // Los administradores pueden leer todos los permisos
      allow read: if (isAuthenticated() && (
                       resource.data.userId == request.auth.uid ||
                       isPlanOwner(resource.data.planId)
                     )) || isAdmin(request.auth.uid);
      
      // Actualizar: Solo el owner del plan puede actualizar permisos
      // Los administradores pueden actualizar cualquier permiso
      allow update: if (isAuthenticated() && 
                       isValidPlanPermissionData() &&
                       isPlanOwner(resource.data.planId) &&
                       request.resource.data.planId == resource.data.planId &&
                       request.resource.data.userId == resource.data.userId &&
                       permissionId == resource.data.planId + '_' + resource.data.userId) ||
                      isAdmin(request.auth.uid);
      
      // Eliminar: Solo el owner del plan puede eliminar permisos
      // Los administradores pueden eliminar cualquier permiso
      allow delete: if (isAuthenticated() && 
                       isPlanOwner(resource.data.planId)) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // REGLAS PARA INVITACIONES POR EMAIL (T104)
    // ============================================
    
    match /plan_invitations/{invitationId} {
      // Crear: solo el owner del plan (o admin) puede crear invitaciones por email
      allow create: if (isAuthenticated() && isValidPlanInvitationData() && isPlanOwner(request.resource.data.planId)) || isAdmin(request.auth.uid);

      // Leer:
      //  - Owner del plan puede leer sus invitaciones
      //  - Usuario autenticado cuyo email coincide con el de la invitación puede leer su propia invitación
      //    (comparación case-insensitive, verifica token o documento de usuario en Firestore)
      //  - Admin puede leer todas
      //  - IMPORTANTE: Permitir lectura sin autenticación solo para invitaciones pendientes (permite acceso por token)
      //    Los tokens son únicos (64 caracteres) y solo se pueden leer invitaciones pendientes, así que es seguro
      allow read: if (isAuthenticated() && (
                        isPlanOwner(resource.data.planId) ||
                        (
                          (request.auth.token.email != null && 
                           request.auth.token.email.toLowerCase() == resource.data.email.toLowerCase()) ||
                          // Fallback: verificar si el usuario en Firestore tiene el mismo email
                          (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email.toLowerCase() == resource.data.email.toLowerCase())
                        )
                     )) || isAdmin(request.auth.uid) || (resource.data.status == 'pending'); // Permitir lectura pública solo para invitaciones pendientes

      // Listar: 
      //  - Permitir a autenticados para consultas con filtros where
      //  - Los filtros where (planId, email) limitan los resultados
      //  - Cada documento devuelto debe cumplir allow read
      //  - IMPORTANTE: Las consultas deben usar where() para limitar resultados
      allow list: if isAuthenticated();

      // Actualizar:
      //  - Owner del plan puede CANCELAR una invitación pendiente (solo cambia 'status' y opcionalmente 'respondedAt')
      //  - El invitado (mismo email) puede ACEPTAR o RECHAZAR su invitación pendiente (solo cambia 'status' y opcionalmente 'respondedAt')
      //  - IMPORTANTE: El usuario invitado DEBE poder actualizar su propia invitación para marcarla como aceptada
      allow update: if isAuthenticated() && (
        (
          // Cancelar por owner
          isPlanOwner(resource.data.planId) &&
          resource.data.status == 'pending' &&
          !('planId' in request.resource.data) &&
          !('email' in request.resource.data) &&
          !('token' in request.resource.data) &&
          !('createdAt' in request.resource.data) &&
          !('expiresAt' in request.resource.data) &&
          (!('role' in request.resource.data) || request.resource.data.role == resource.data.role) &&
          ('status' in request.resource.data) && request.resource.data.status == 'cancelled'
        ) || (
          // Aceptar / Rechazar por el invitado
          // Verificar que el email del token coincide con el email de la invitación (case-insensitive)
          // También permitir si el email del usuario en Firestore coincide (para casos donde el token no tiene email)
          (
            (request.auth.token.email != null &&
             request.auth.token.email.toLowerCase() == resource.data.email.toLowerCase()) ||
            // Fallback: verificar si el usuario en Firestore tiene el mismo email
            (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email.toLowerCase() == resource.data.email.toLowerCase())
          ) &&
          resource.data.status == 'pending' &&
          !('planId' in request.resource.data) &&
          !('email' in request.resource.data) &&
          !('token' in request.resource.data) &&
          !('createdAt' in request.resource.data) &&
          !('expiresAt' in request.resource.data) &&
          (!('role' in request.resource.data) || request.resource.data.role == resource.data.role) &&
          ('status' in request.resource.data) && request.resource.data.status in ['accepted', 'rejected']
        )
      ) || isAdmin(request.auth.uid);

      // Eliminar: owner del plan o admin
      allow delete: if (isAuthenticated() && isPlanOwner(resource.data.planId)) || isAdmin(request.auth.uid);
    }
    
    // ============================================
    // DENEGAR TODO LO DEMÁS POR DEFECTO
    // ============================================
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

